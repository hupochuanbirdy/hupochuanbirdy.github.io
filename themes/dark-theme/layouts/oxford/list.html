{{- define "main" }}

<section class="music-section" id="music">
    <div class="container">
        <!-- Header -->
        <div class="text-center mb-4">
            <h1 class="section-title">üéµ Collection</h1>
            <p class="section-subtitle">Discover and enjoy your favorite tracks</p>
        </div>

        <!-- Add this near the top of your layout, after the Collection title -->
        <div class="pdf-download-section" style="text-align: center; margin: 20px 0;">
            <button onclick="window.open(pdfLink, '_blank')" 
                    class="pdf-download-btn"
                    style="background: linear-gradient(135deg, #1e3a8a, #3b82f6); 
                           color: white; 
                           padding: 12px 24px; 
                           border: none; 
                           border-radius: 25px; 
                           font-weight: 600;
                           cursor: pointer;
                           box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);">
                üìñ Download Oxford PDF Textbook
            </button>
        </div>

        <!-- Main Music Interface -->
        <div class="music-interface ">
             <!-- Right Side: Music Player -->
             <div class="music-player-container flex-1">
                <div class="now-playing">
                    <div class="track-info">
                        <h3 id="track-title">Select a track</h3>
                        <p id="track-artist">No artist</p>
                    </div>
                </div>
                
                <div class="progress-container">
                    <span id="current-time">0:00</span>
                    <input type="range" id="progress-bar" class="progress-bar" min="0" max="100" value="0">
                    <span id="duration">0:00</span>
                </div>
                
                <div class="controls">
                    <button class="control-btn" id="prev-btn">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 6h2v12H6V6zm3.5 6l8.5 6V6l-8.5 6z"/>
                        </svg>
                    </button>
                    <button class="control-btn play-btn" id="play-pause-btn">
                        <svg id="play-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        <svg id="pause-icon" viewBox="0 0 24 24" fill="currentColor" style="display: none;">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                    </button>
                    <button class="control-btn" id="next-btn">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                        </svg>
                    </button>
                </div>
                
                <audio id="audio-player" preload="metadata"></audio>
            </div>
            <div class="music-sidebar flex-1">
                <!-- Track List -->
                <div class="track-container">
                    <div class="cd-tabs">
                        <div id="cd-tab-buttons" class="tab-buttons"></div>
                    </div>
                    <div id="cd-track-content" class="tab-content"></div>
                </div>
            </div>

           
        </div>
    </div>
</section>

<!-- Load Music Player CSS -->
<link rel="stylesheet" href="{{ "css/music-player.css" | relURL }}">

<style>
.music-section {
    padding: 2rem 0;
    min-height: 100vh;
}

.section-title {
    font-size: 2.5rem;
    color: var(--main-color);
    margin-bottom: 0.5rem;
}

.section-subtitle {
    color: var(--text-color);
    opacity: 0.7;
    font-size: 1.1rem;
}

.music-interface {
    display: flex;
    gap: 1rem;
    margin: 0 auto;
}


.music-player-container .now-playing {
    justify-content: center;
    text-align: center;
}

/* CD Tabs Styling */
.cd-tabs {
    margin-bottom: 1rem;
}

.tab-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
    justify-content: center;
}

.tab-button {
    background: var(--background-color);
    border: 2px solid var(--main-color);
    color: var(--main-color);
    padding: 0.8rem 1.5rem;
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 600;
    font-size: 0.9rem;
    position: relative;
    overflow: hidden;
}

.tab-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: left 0.5s;
}

.tab-button:hover::before {
    left: 100%;
}

.tab-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(var(--main-color-rgb), 0.3);
}

.tab-button.active {
    background: var(--main-color);
    color: white;
    transform: translateY(-2px);
    box-shadow: 0 5px 20px rgba(var(--main-color-rgb), 0.4);
}

/* Track Container */
.track-container {
    background: var(--background-color);
    border: 1px solid var(--main-color);
    border-radius: 20px;
    padding: 10px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    min-height: 400px;
}

.individual-tab-content {
    display: none;
    height: 300px;
    overflow: auto;
}

.individual-tab-content.active {
    display: block;
}

.track-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: grid;
    gap: 0.5rem;
}

.track-item {
    transition: all 0.3s ease;
    border-radius: 12px;
    padding: 0;
    position: relative;
    overflow: hidden;
    background: rgba(var(--main-color-rgb), 0.02);
    border: 1px solid transparent;
    counter-increment: track-counter;
}

.track-item:hover {
    background: rgba(var(--main-color-rgb), 0.08);
    border-color: rgba(var(--main-color-rgb), 0.3);
    transform: translateX(2px);
}

.track-item.playing {
    background: linear-gradient(135deg, var(--main-color), rgba(var(--main-color-rgb), 0.8));
    color: white;
    transform: translateX(8px);
    box-shadow: 0 4px 15px rgba(var(--main-color-rgb), 0.3);
}

.track-item.playing::before {
    content: '‚ô™';
    position: absolute;
    left: 1rem;
    top: 50%;
    transform: translateY(-50%);
    font-size: 1.2rem;
    color: white;
    animation: pulse 1.5s infinite;
    z-index: 2;
}

@keyframes pulse {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
}

.track-item.playing .track-link {
    color: white;
    padding-left: 3rem;
    background-color: var(--main-color);
}

.track-link {
    color: var(--text-color);
    text-decoration: none;
    display: block;
    padding: 10px;
    padding-left: 3.5rem;
    border-radius: 12px;
    transition: all 0.2s ease;
    font-weight: 500;
    position: relative;
    cursor: pointer;
}

.track-link:hover {
    color: var(--main-color);
    background: transparent;
}


.track-link::before {
    content: counter(track-counter, decimal-leading-zero);
    position: absolute;
    left: 1rem;
    top: 50%;
    transform: translateY(-30%);
    font-size: 0.8rem;
    opacity: 0.5;
    font-weight: 600;
    min-width: 1.5rem;
}

.track-item.playing .track-link::before {
    display: none;
}

.track-link::after {
    content: '‚ñ∂';
    position: absolute;
    right: 1.5rem;
    top: 50%;
    transform: translateY(-50%);
    opacity: 0;
    transition: all 0.2s ease;
    font-size: 0.8rem;
}

.track-item:hover .track-link::after {
    opacity: 0.7;
}

.track-item.playing .track-link::after {
    content: '‚è∏';
    opacity: 1;
}

/* Track restoration highlight effect */
.track-item.track-restored {
    animation: trackRestored 2s ease-in-out;
    border: 2px solid var(--main-color);
    box-shadow: 0 0 20px rgba(var(--main-color-rgb), 0.4);
}

.track-item.track-restored .track-link {
    background: linear-gradient(90deg, rgba(var(--main-color-rgb), 0.1), rgba(var(--main-color-rgb), 0.05), rgba(var(--main-color-rgb), 0.1));
    color: var(--main-color);
    font-weight: 600;
}

@keyframes trackRestored {
    0% {
        transform: scale(1);
        box-shadow: 0 0 0 rgba(var(--main-color-rgb), 0.4);
    }
    25% {
        transform: scale(1.02);
        box-shadow: 0 0 20px rgba(var(--main-color-rgb), 0.6);
    }
    50% {
        transform: scale(1.01);
        box-shadow: 0 0 15px rgba(var(--main-color-rgb), 0.5);
    }
    100% {
        transform: scale(1);
        box-shadow: 0 0 5px rgba(var(--main-color-rgb), 0.3);
    }
}

/* Reset counter for each tab content */
.individual-tab-content {
    counter-reset: track-counter;
}

/* Responsive Design */
@media (max-width: 768px) {
    .section-title {
        font-size: 2rem;
    }
    
    .music-interface {
        display: block;
    }
    
    .tab-buttons {
        justify-content: center;
    }
    
    .tab-button {
        padding: 0.6rem 1.2rem;
        font-size: 0.8rem;
    }
    
    .track-container {
        padding: 1rem;
    }
    
    .track-link {
        padding: 0.8rem 1rem;
        padding-left: 3rem;
        font-size: 0.9rem;
    }
    
    .track-link::before {
        left: 0.8rem;
    }
}

@media (max-width: 480px) {
    
    
    .tab-button {
        text-align: center;
    }
    
    .track-link {
        padding: 0.7rem 0.8rem;
        padding-left: 2.5rem;
    }
    
    .track-link::before {
        left: 0.6rem;
        font-size: 0.7rem;
    }
}

/* Restoration Notification Styles */
.restoration-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background: var(--background-color);
    border: 2px solid var(--main-color);
    border-radius: 12px;
    padding: 1rem;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    z-index: 1000;
    animation: slideInRight 0.3s ease-out;
    max-width: 300px;
    backdrop-filter: blur(10px);
}

.restoration-notification.fade-out {
    animation: fadeOut 0.3s ease-out;
}

.notification-content {
    display: flex;
    align-items: center;
    gap: 0.8rem;
}

.notification-icon {
    font-size: 1.5rem;
    animation: spin 1s linear infinite;
}

.notification-text {
    color: var(--text-color);
    font-size: 0.9rem;
    line-height: 1.3;
}

.notification-text strong {
    color: var(--main-color);
}

@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes fadeOut {
    from {
        opacity: 1;
    }
    to {
        opacity: 0;
    }
}

@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}

@media (max-width: 480px) {
    .restoration-notification {
        top: 10px;
        right: 10px;
        left: 10px;
        max-width: none;
    }
}

</style>

<script>
    const pdfLink ='https://hupo-common.s3.ap-northeast-2.amazonaws.com/oxford-en/OPD+Version+3.pdf'
class MusicPlayer {
    constructor() {
        this.playlist = [];
        this.currentTrackIndex = 0;
        this.isPlaying = false;
        this.currentCdTab = null;
        this.lastPlayedTrack = null; // Track the last played track
        
        this.audio = document.getElementById('audio-player');
        this.playPauseBtn = document.getElementById('play-pause-btn');
        this.prevBtn = document.getElementById('prev-btn');
        this.nextBtn = document.getElementById('next-btn');
        this.progressBar = document.getElementById('progress-bar');
        this.currentTimeEl = document.getElementById('current-time');
        this.durationEl = document.getElementById('duration');
        this.trackTitleEl = document.getElementById('track-title');
        this.trackArtistEl = document.getElementById('track-artist');
        this.playIcon = document.getElementById('play-icon');
        this.pauseIcon = document.getElementById('pause-icon');
        
        this.initializeEventListeners();
    }
    
    initializeEventListeners() {
        // Play/Pause button
        this.playPauseBtn.addEventListener('click', () => {
            this.togglePlayPause();
        });
        
        // Previous button
        this.prevBtn.addEventListener('click', () => {
            this.previousTrack();
        });
        
        // Next button
        this.nextBtn.addEventListener('click', () => {
            this.nextTrack();
        });
        
        // Progress bar
        this.progressBar.addEventListener('input', () => {
            this.seek();
        });
        
        // Audio events
        this.audio.addEventListener('timeupdate', () => {
            this.updateProgress();
            // Save state every 5 seconds during playback
            if (this.isPlaying && Math.floor(this.audio.currentTime) % 5 === 0) {
                this.savePlaybackState();
            }
        });
        
        this.audio.addEventListener('loadedmetadata', () => {
            this.updateDuration();
        });
        
        this.audio.addEventListener('ended', () => {
            this.nextTrack();
        });
        
        // Enhanced saving events
        this.audio.addEventListener('play', () => {
            this.savePlaybackState();
        });
        
        this.audio.addEventListener('pause', () => {
            this.savePlaybackState();
        });
        
        this.audio.addEventListener('seeked', () => {
            this.savePlaybackState();
        });
        
        // Save state when page is about to be unloaded
        window.addEventListener('beforeunload', () => {
            this.savePlaybackState();
        });
        
        // Save state when page becomes hidden (mobile/tab switching)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                this.savePlaybackState();
            }
        });
        
        // Periodic backup save every 10 seconds
        setInterval(() => {
            if (this.isPlaying) {
                this.savePlaybackState();
            }
        }, 10000);
    }
    
    loadPlaylist(playlist) {
        this.playlist = playlist;
        if (playlist.length > 0) {
            // Try to load the last played track, otherwise load first track
            const lastPlayed = this.getLastPlayedTrack();
            if (lastPlayed && lastPlayed.url) {
                const trackIndex = playlist.findIndex(track => track.url === lastPlayed.url);
                if (trackIndex !== -1) {
                    this.loadTrack(trackIndex, false);
                    // Restore last position if it was significant (more than 1 second)
                    if (lastPlayed.currentTime && lastPlayed.currentTime > 1) {
                        this.restorePlaybackState(lastPlayed);
                    }
                    // Switch to the correct tab for the restored track
                    this.switchToTrackTab(trackIndex);
                    // Show restoration notification
                    this.showRestorationNotification(lastPlayed);
                    console.log(`üéµ Restored: ${playlist[trackIndex].title} at ${this.formatTime(lastPlayed.currentTime)}`);
                } else {
                    this.loadTrack(0, false);
                    console.log('‚ùå Last played track not found, loading first track');
                }
            } else {
                this.loadTrack(0, false);
                console.log('üìÄ No previous session found, loading first track');
            }
        }
    }
    
    loadTrack(index, autoPlay = false) {
        if (index < 0 || index >= this.playlist.length) return;
        
        // Save previous track as last played
        if (this.currentTrackIndex !== index && this.playlist[this.currentTrackIndex]) {
            this.lastPlayedTrack = {
                ...this.playlist[this.currentTrackIndex],
                currentTime: this.audio.currentTime || 0,
                timestamp: Date.now()
            };
        }
        
        this.currentTrackIndex = index;
        const track = this.playlist[index];
        
        this.audio.src = track.url;
        this.trackTitleEl.textContent = track.title;
        this.trackArtistEl.textContent = track.artist;
        
        this.updateTrackListState();
        
        if (autoPlay) {
            this.play();
        }
        
        // Reset progress
        this.progressBar.value = 0;
        this.currentTimeEl.textContent = '0:00';
        
        // Save current track info
        this.saveLastPlayedTrack(track);
    }
    
    play() {
        this.audio.play().then(() => {
            this.isPlaying = true;
            this.updatePlayButton();
        }).catch(error => {
            console.log("Play blocked by browser:", error);
        });
    }
    
    pause() {
        this.audio.pause();
        this.isPlaying = false;
        this.updatePlayButton();
    }
    
    togglePlayPause() {
        if (this.playlist.length === 0) return;
        
        if (this.isPlaying) {
            this.pause();
        } else {
            this.play();
        }
    }
    
    previousTrack() {
        if (this.playlist.length === 0) return;
        
        let newIndex = this.currentTrackIndex - 1;
        if (newIndex < 0) {
            newIndex = this.playlist.length - 1;
        }
        this.loadTrack(newIndex, this.isPlaying);
    }
    
    nextTrack() {
        if (this.playlist.length === 0) return;
        
        let newIndex = this.currentTrackIndex + 1;
        if (newIndex >= this.playlist.length) {
            newIndex = 0;
        }
        this.loadTrack(newIndex, this.isPlaying);
    }
    
    seek() {
        const duration = this.audio.duration;
        if (duration) {
            this.audio.currentTime = (this.progressBar.value / 100) * duration;
        }
    }
    
    updateProgress() {
        const currentTime = this.audio.currentTime;
        const duration = this.audio.duration;
        
        if (duration) {
            this.progressBar.value = (currentTime / duration) * 100;
            this.currentTimeEl.textContent = this.formatTime(currentTime);
        }
    }
    
    updateDuration() {
        this.durationEl.textContent = this.formatTime(this.audio.duration);
    }
    
    updatePlayButton() {
        if (this.isPlaying) {
            this.playIcon.style.display = 'none';
            this.pauseIcon.style.display = 'block';
        } else {
            this.playIcon.style.display = 'block';
            this.pauseIcon.style.display = 'none';
        }
    }
    
    updateTrackListState() {
        // Remove all state classes from tracks
        document.querySelectorAll(".track-item").forEach(item => {
            item.classList.remove("playing", "last-played");
        });
        
        // Add playing class to current track
        const currentTrack = this.playlist[this.currentTrackIndex];
        if (currentTrack && currentTrack.element) {
            currentTrack.element.classList.add("playing");
            
            // Switch to the correct tab if the playing track is in a different tab
            const tabContent = currentTrack.element.closest('.individual-tab-content');
            if (tabContent && !tabContent.classList.contains('active')) {
                const tabId = tabContent.id;
                const tabButton = document.querySelector(`[data-tab="${tabId}"]`);
                if (tabButton) {
                    switchTab(tabButton, tabId);
                }
            }
        }
        
        // Add last-played class to previously played track
        if (this.lastPlayedTrack && this.lastPlayedTrack.element && 
            this.lastPlayedTrack.url !== currentTrack.url) {
            this.lastPlayedTrack.element.classList.add("last-played");
        }
    }
    
    // LocalStorage methods for persistence
    saveLastPlayedTrack(track) {
        const trackData = {
            title: track.title,
            artist: track.artist,
            url: track.url,
            timestamp: Date.now()
        };
        localStorage.setItem('musicPlayer_lastTrack', JSON.stringify(trackData));
    }
    
    savePlaybackState() {
        if (this.playlist[this.currentTrackIndex] && this.audio.currentTime >= 0) {
            const currentTrack = this.playlist[this.currentTrackIndex];
            const playbackState = {
                title: currentTrack.title,
                artist: currentTrack.artist,
                url: currentTrack.url,
                currentTime: this.audio.currentTime,
                duration: this.audio.duration || 0,
                isPlaying: this.isPlaying,
                volume: this.audio.volume,
                trackIndex: this.currentTrackIndex,
                timestamp: Date.now(),
                tabInfo: this.getCurrentTabInfo()
            };
            localStorage.setItem('musicPlayer_playbackState', JSON.stringify(playbackState));
        }
    }
    
    restorePlaybackState(playbackState) {
        // Wait for audio metadata to load before setting currentTime
        const attemptRestore = () => {
            if (this.audio.readyState >= 1) { // HAVE_METADATA
                this.audio.currentTime = playbackState.currentTime;
                if (playbackState.volume !== undefined) {
                    this.audio.volume = playbackState.volume;
                }
                this.updateProgress();
                console.log(`üéµ Restored playback: ${this.formatTime(playbackState.currentTime)}/${this.formatTime(playbackState.duration)}`);
                
                // If the track was playing when saved, offer to resume (but don't auto-play due to browser restrictions)
                if (playbackState.isPlaying) {
                    console.log('‚ñ∂Ô∏è Track was playing when saved. Click play to resume.');
                }
            } else {
                // If metadata not loaded yet, try again in 100ms
                setTimeout(attemptRestore, 100);
            }
        };
        
        // Start attempting to restore
        attemptRestore();
    }
    
    getLastPlayedTrack() {
        try {
            const saved = localStorage.getItem('musicPlayer_playbackState');
            return saved ? JSON.parse(saved) : null;
        } catch (error) {
            console.error('Error loading last played track:', error);
            return null;
        }
    }
    
    loadLastPlayedTrack() {
        try {
            // Load the last played track info (for visual indicators)
            const saved = localStorage.getItem('musicPlayer_lastTrack');
            if (saved) {
                this.lastPlayedTrack = JSON.parse(saved);
                console.log('Loaded last played track from storage:', this.lastPlayedTrack.title);
            }
            
            // Also try to load the playback state for restoration
            const playbackState = this.getLastPlayedTrack();
            if (playbackState) {
                console.log('Found saved playback state:', playbackState.title, 'at', playbackState.currentTime, 'seconds');
            }
        } catch (error) {
            console.error('Error loading last played track from storage:', error);
        }
    }
    
    formatTime(seconds) {
        if (!seconds || isNaN(seconds)) return '0:00';
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
    }
    
    playTrackByUrl(url) {
        const trackIndex = this.playlist.findIndex(track => track.url === url);
        if (trackIndex !== -1) {
            this.loadTrack(trackIndex, true);
        }
    }
    
    // Method to get recently played tracks (for future features)
    getRecentlyPlayed(limit = 10) {
        try {
            const recent = localStorage.getItem('musicPlayer_recentTracks');
            return recent ? JSON.parse(recent).slice(0, limit) : [];
        } catch (error) {
            console.error('Error loading recent tracks:', error);
            return [];
        }
    }

    linkLastPlayedTrackElement() {
        if (this.lastPlayedTrack && this.lastPlayedTrack.url && this.playlist.length > 0) {
            const matchingTrack = this.playlist.find(track => track.url === this.lastPlayedTrack.url);
            if (matchingTrack && matchingTrack.element) {
                this.lastPlayedTrack.element = matchingTrack.element;
                console.log('Linked DOM element for last played track:', this.lastPlayedTrack.title);
            }
        }
    }
    
    // Enhanced method to switch to the correct tab for a track and scroll to it
    switchToTrackTab(trackIndex) {
        const track = this.playlist[trackIndex];
        if (track && track.element) {
            const tabContent = track.element.closest('.individual-tab-content');
            if (tabContent && !tabContent.classList.contains('active')) {
                const tabId = tabContent.id;
                const tabButton = document.querySelector(`[data-tab="${tabId}"]`);
                if (tabButton) {
                    switchTab(tabButton, tabId);
                    console.log(`üîÑ Switched to tab: ${tabButton.textContent}`);
                    
                    // Wait for tab switch animation to complete, then scroll to track
                    setTimeout(() => {
                        this.scrollToTrack(trackIndex);
                    }, 300);
                }
            } else {
                // If already on correct tab, just scroll to track
                this.scrollToTrack(trackIndex);
            }
        }
    }
    
    // Scroll to and highlight a specific track in the list
    scrollToTrack(trackIndex) {
        const track = this.playlist[trackIndex];
        if (track && track.element) {
            // Add temporary highlight class
            track.element.classList.add('track-restored');
            
            // Scroll the track into view smoothly
            track.element.scrollIntoView({
                behavior: 'smooth',
                block: 'center',
                inline: 'nearest'
            });
            
            // Also ensure the track container is scrolled properly
            const trackContainer = track.element.closest('.individual-tab-content');
            if (trackContainer) {
                const containerRect = trackContainer.getBoundingClientRect();
                const trackRect = track.element.getBoundingClientRect();
                
                // If track is not fully visible in container, scroll container
                if (trackRect.top < containerRect.top || trackRect.bottom > containerRect.bottom) {
                    const scrollTop = track.element.offsetTop - trackContainer.offsetTop - (trackContainer.clientHeight / 2) + (track.element.clientHeight / 2);
                    trackContainer.scrollTo({
                        top: scrollTop,
                        behavior: 'smooth'
                    });
                }
            }
            
            console.log(`üìç Scrolled to restored track: ${track.title}`);
            
            // Remove highlight after animation
            setTimeout(() => {
                track.element.classList.remove('track-restored');
            }, 2000);
        }
    }
    
    getCurrentTabInfo() {
        const activeTab = document.querySelector('.tab-button.active');
        return activeTab ? {
            tabName: activeTab.textContent,
            tabId: activeTab.dataset.tab
        } : null;
    }
    
    // Visual feedback for restoration
    showRestorationNotification(playbackState) {
        const notification = document.createElement('div');
        notification.className = 'restoration-notification';
        notification.innerHTML = `
            <div class="notification-content">
                <span class="notification-icon">üîÑ</span>
                <div class="notification-text">
                    <strong>Resuming playback</strong>
                    <br>${playbackState.title} - ${this.formatTime(playbackState.currentTime)}
                    <br><small>Jumping to track in list...</small>
                </div>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 4 seconds (longer to show the jumping message)
        setTimeout(() => {
            notification.classList.add('fade-out');
            setTimeout(() => notification.remove(), 300);
        }, 4000);
    }
    
    // Clear saved data (useful for testing or user preference)
    clearSavedData() {
        localStorage.removeItem('musicPlayer_playbackState');
        localStorage.removeItem('musicPlayer_lastTrack');
        localStorage.removeItem('musicPlayer_recentTracks');
        console.log('üóëÔ∏è Cleared all saved music data');
    }
}

let musicPlayer;

function switchTab(button, tabId) {
    console.log(`Switching to tab: ${tabId}`);
    
    // Remove active class from all buttons and contents
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.individual-tab-content').forEach(content => content.classList.remove('active'));
    
    // Add active class to clicked button and corresponding content
    button.classList.add('active');
    const targetContent = document.getElementById(tabId);
    if (targetContent) {
        targetContent.classList.add('active');
        console.log(`Successfully switched to ${tabId}`);
    } else {
        console.error(`Could not find tab content with ID: ${tabId}`);
    }
}

async function loadMP3s() {
    console.log('Starting to load MP3s...');
    
    try {
        console.log('Fetching mp3list.json...');
        const response = await fetch("/mp3list.json");
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const cds = await response.json();
        console.log('MP3 data loaded:', cds);
        
        const tabButtons = document.getElementById("cd-tab-buttons");
        const tabContentContainer = document.getElementById("cd-track-content");
        
        console.log('Tab buttons element:', tabButtons);
        console.log('Tab content container:', tabContentContainer);
        
        if (!tabButtons || !tabContentContainer) {
            console.error('Tab containers not found!');
            console.log('Available elements with id:', document.querySelectorAll('[id]'));
            return;
        }
        
        // Clear existing content
        tabButtons.innerHTML = '';
        tabContentContainer.innerHTML = '';
        
        // Build playlist for the music player
        const playlist = [];
        let firstTab = true;
        
        Object.keys(cds).forEach((cdName, cdIndex) => {
            console.log(`Processing ${cdName} with ${cds[cdName].length} tracks`);
            
            // Create tab button
            const tabButton = document.createElement("button");
            tabButton.className = `tab-button ${firstTab ? 'active' : ''}`;
            tabButton.textContent = cdName;
            tabButton.dataset.tab = `cd-${cdIndex}`;
            
            tabButton.onclick = () => {
                switchTab(tabButton, `cd-${cdIndex}`);
            };
            
            tabButtons.appendChild(tabButton);
            console.log(`Added tab button for ${cdName}`);
            
            // Create individual tab content (not using the container's class)
            const contentDiv = document.createElement("div");
            contentDiv.className = `individual-tab-content ${firstTab ? 'active' : ''}`;
            contentDiv.id = `cd-${cdIndex}`;
            
           
            
            const ul = document.createElement("ul");
            ul.className = "track-list";
            
            cds[cdName].forEach((url, index) => {
                const li = document.createElement("li");
                li.className = "track-item";
                
                const link = document.createElement("a");
                link.className = "track-link";
                link.href = "#";
                
                // Clean up the filename for display
                const filename = decodeURIComponent(url.split("/").pop());
                const trackName = filename.replace(/\.[^/.]+$/, "").replace(/\+/g, " ");
                link.textContent = trackName;
                
                // Add to playlist
                const trackData = {
                    title: trackName,
                    artist: cdName,
                    url: url,
                    element: li
                };
                playlist.push(trackData);
                
                link.onclick = (e) => {
                    e.preventDefault();
                    console.log(`Playing track: ${trackName}`);
                    musicPlayer.playTrackByUrl(url);
                    return false;
                };
                
                li.appendChild(link);
                ul.appendChild(li);
            });
            
            contentDiv.appendChild(ul);
            tabContentContainer.appendChild(contentDiv);
            console.log(`Added tab content for ${cdName} with ${cds[cdName].length} tracks`);
            
            firstTab = false;
        });
        
        console.log(`Total playlist created with ${playlist.length} tracks`);
        console.log('Final DOM structure:', {
            tabButtons: tabButtons.children.length,
            tabContents: tabContentContainer.children.length
        });
        
        // Initialize the music player with the playlist
        if (playlist.length > 0) {
            musicPlayer.loadPlaylist(playlist);
            console.log('Music player loaded with playlist');
            
            // Ensure DOM elements are linked after a short delay
            setTimeout(() => {
                musicPlayer.linkLastPlayedTrackElement();
            }, 500);
        }
        
    } catch (error) {
        console.error('Error loading MP3s:', error);
        const tabContentContainer = document.getElementById("cd-track-content");
        if (tabContentContainer) {
            tabContentContainer.innerHTML = `<p style="text-align: center; color: var(--text-color); opacity: 0.7;">Failed to load music collection: ${error.message}<br>Please check the browser console for more details.</p>`;
        }
    }
}

// Initialize the page
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing music player...');
    
    // Add a small delay to ensure all elements are rendered
    setTimeout(() => {
        console.log('Initializing with delay...');
        musicPlayer = new MusicPlayer();
        loadMP3s();
    }, 100);
});
</script>

{{- end }}